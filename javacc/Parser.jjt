PARSER_BEGIN(Parser)

public class Parser
{
    public static int errorLimit = 10;
    public static int errorCounter = 0;
}

PARSER_END(Parser)

SKIP:
{
    " " | "\n" | "\t" | "\r"
}

TOKEN:
{
    < INTEGERLITERAL : (["0"-"9"])+ >
    | < IF : "if">
    | < INT : "int">
    | < NEW : "new">
    | < VOID : "void">
    | < ELSE : "else">
    | < TRUE : "true">
    | < MAIN : "main">
    | < THIS : "this">
    | < WHILE : "while">
    | < FALSE : "false">
    | < CLASS : "class">
    | < PUBLIC : "public">
    | < STATIC : "static">
    | < STRING : "String">
    | < LENGTH : "length">
    | < RETURN : "return">
    | < IMPORT : "import">
    | < BOOLEAN : "boolean">
    | < EXTENDS : "extends">
    | < OPENPAR : "(">
    | < CLOSEPAR : ")">
    | < SEMICOLON : ";">
    | < OPENCUR : "{">
    | < IDENTIFIER : (["a"-"z","A"-"Z"])(["a"-"z","A"-"Z","0"-"9","_"])* >
}

JAVACODE
void error_skipto(String description) #void {
    ParseException e = generateParseException();  // generate the exception object
    Token t;

    t = getToken(1);
    System.out.println("Unexpected \"" + t.image + "\" in " + description + " at line " + t.beginLine + "!");

    while(t.kind != SEMICOLON && t.kind != EOF && t.kind != OPENCUR && t.kind != CLOSEPAR)
    {
        t = getNextToken();
        t = getToken(1);
    }

}

SimpleNode Program() : {}
{
    ImportDeclaration() ClassDeclaration() <EOF> {return jjtThis;}
}

void ImportDeclaration() : {}
{
    (<IMPORT> <IDENTIFIER> ("." <IDENTIFIER>)* #ImportMaterial <SEMICOLON>)*
}

void ClassDeclaration() : {Token t;}
{
    <CLASS> (t=<IDENTIFIER> {jjtThis.val = t.image;} #ClassName) (<EXTENDS> <IDENTIFIER>)? <OPENCUR> (VarDeclaration())* (MethodDeclaration())* "}"
}

void VarDeclaration() : {}
{
    Type() <IDENTIFIER> #VarName <SEMICOLON>
}

void MethodDeclaration() : {}
{
    <PUBLIC> ((Type() #ReturnType) <IDENTIFIER> <OPENPAR> (Type() <IDENTIFIER> ("," Type() <IDENTIFIER> )* )? <CLOSEPAR> <OPENCUR> (LOOKAHEAD(2) VarDeclaration())* (Statement())* <RETURN> Expression() <SEMICOLON> "}"
    | <STATIC> <VOID> <MAIN> <OPENPAR> <STRING> "[" "]" <IDENTIFIER>  <CLOSEPAR> <OPENCUR> (LOOKAHEAD(2) VarDeclaration())* (Statement())* "}" )
}

void Type() : {Token t1;}
{
    <INT> {jjtThis.val = "int";} ("[" "]" {jjtThis.val += "[]";})? 
    | <BOOLEAN> {jjtThis.val = "boolean";} #Boolean
    | t1=<IDENTIFIER> {jjtThis.val = t1.image;} #TypeName
}

void Statement() : {} 
{
    <OPENCUR> (Statement() )* "}"
    | <IF> #If <OPENPAR> Expression() <CLOSEPAR> Statement() <ELSE> #Else Statement()
    | <WHILE> #While <OPENPAR> 
   try 
   {
        Expression()
   }
   catch(ParseException e)
   {
       error_skipto("while expression");
       errorCounter++;
       if (errorCounter == errorLimit) throw e;   
   } <CLOSEPAR> Statement()
    | Expression3() <SEMICOLON>
    | Identifier() (
        "=" Assignee() #Assign(2) 
            | "[" Expression() "]" ("=" #Assign Expression() <SEMICOLON> | ExpressionLFRFix())
            | ExpressionLFRFix2() <SEMICOLON> )
}

void Identifier() : {}
{
    <IDENTIFIER>
}

void Assignee() : {}
{
    Expression() <SEMICOLON>
}

void Expression() #void : {}
{
    <INTEGERLITERAL> #IntegerLiteral ExpressionLFRFix()
    | <TRUE> #True ExpressionLFRFix()
    | <FALSE> #False ExpressionLFRFix()
    | <IDENTIFIER> #VariableName ExpressionLFRFix()
    | <THIS> #This ExpressionLFRFix()
    | (<NEW> #New) (<INT> "[" Expression() "]" | <IDENTIFIER> <OPENPAR> <CLOSEPAR>) ExpressionLFRFix()
    | "!" #Negation Expression() ExpressionLFRFix()
    | <OPENPAR> Expression() <CLOSEPAR> ExpressionLFRFix()
}

void Expression3() #void : {}
{
    <INTEGERLITERAL> #IntegerLiteral ExpressionLFRFix()
    | <TRUE> #True ExpressionLFRFix()
    | <FALSE> #False ExpressionLFRFix()
    | <THIS> #This ExpressionLFRFix()
    | (<NEW> #New) (<INT> "[" Expression() "]" | <IDENTIFIER> <OPENPAR> <CLOSEPAR>) ExpressionLFRFix()
    | "!" #Negation Expression() ExpressionLFRFix()
    | <OPENPAR> Expression() <CLOSEPAR> ExpressionLFRFix() 
}

void ExpressionLFRFix() #void : {}
{
    (LOOKAHEAD(2) (Operator() Expression() ExpressionLFRFix()
    | "[" Expression() "]" ExpressionLFRFix()
    | "." ( <IDENTIFIER> #MethodName <OPENPAR> (Expression() ( "," Expression())*)? <CLOSEPAR> ExpressionLFRFix()  | <LENGTH> #Length ExpressionLFRFix())  ))?
}

void ExpressionLFRFix2() #void : {}
{
    (Operator() Expression() ExpressionLFRFix()
    | "." ( <IDENTIFIER> #MethodName <OPENPAR> (Expression() ( "," Expression())*)? <CLOSEPAR> ExpressionLFRFix()  | <LENGTH> #Length ExpressionLFRFix()  ))?
}

void Operator() #void : {}
{
    ( "&&" #And | "<" #SmallerThan | "+" #Addition | "-" #Subtraction | "*" #Multiplication | "/" #Division )
}
