PARSER_BEGIN(jmm)

import java.security.PublicKey;
import java.io.FileInputStream;
import java.io.FileNotFoundException;

public class jmm
{
    public static void main(String args[]) throws ParseException, FileNotFoundException
    {
        jmm parser = new jmm(new FileInputStream(args[0]));
        jmm.Program(); 
    }
}

PARSER_END(jmm)

SKIP:
{
    " " | "\n"
}

TOKEN:
{
    < INTEGERLITERAL : (["0"-"9"])+ >
    | < IF : "if">
    | < INT : "int">
    | < NEW : "new">
    | < VOID : "void">
    | < ELSE : "else">
    | < TRUE : "true">
    | < MAIN : "main">
    | < THIS : "this">
    | < WHILE : "while">
    | < FALSE : "false">
    | < CLASS : "class">
    | < PUBLIC : "public">
    | < STATIC : "static">
    | < STRING : "String">
    | < LENGTH : "length">
    | < RETURN : "return">
    | < IMPORT : "import">
    | < BOOLEAN : "boolean">
    | < EXTENDS : "extends">
    | < OPENPAR : "(" >
    | < CLOSEPAR : ")" >
    | < IDENTIFIER : (["a"-"z","A"-"Z"])(["a"-"z","A"-"Z","0"-"9","_"])* >
}

JAVACODE
void error_skipto(int kind) {
  ParseException e = generateParseException();  // generate the exception object
  System.out.println(e.toString());  // print the error message
  Token t;
  // consume tokens all the way up to a token of "kind" - use a do-while loop
  // rather than a while because the current token is the one immediately before
  // the erroneous token (in our case the token immediately before what should
  // have been "if"/"while".
  do {
    t = getNextToken();
  }
  while (t.kind != kind);
}

void Program() : {}
{
    ImportDeclaration() ClassDeclaration() <EOF>
}

void ImportDeclaration() :{}
{
    (<IMPORT> <IDENTIFIER> ("." <IDENTIFIER>)* ";")*
}

void ClassDeclaration() :{}
{
    <CLASS> <IDENTIFIER> (<EXTENDS> <IDENTIFIER>)? "{" (VarDeclaration())* (MethodDeclaration())* "}"
}

void VarDeclaration() : {}
{
    Type() <IDENTIFIER> ";"
}

void MethodDeclaration() : {}
{
    <PUBLIC> (Type() <IDENTIFIER> <OPENPAR> (Type() <IDENTIFIER> ("," Type() <IDENTIFIER> )* )? <CLOSEPAR> "{" (LOOKAHEAD(2) VarDeclaration())* (Statement())* <RETURN> Expression() ";" "}"
    | <STATIC> <VOID> <MAIN> <OPENPAR> <STRING> "[" "]" <IDENTIFIER>  <CLOSEPAR> "{" (LOOKAHEAD(2) VarDeclaration())* (Statement())* "}" )
}

void Type() : {}
{
    <INT> ("[" "]")?
    | <BOOLEAN>
    | <IDENTIFIER>
}

void Statement() : {} 
{
    "{" (Statement() )* "}"
    | <IF> <OPENPAR> Expression() <CLOSEPAR> Statement() <ELSE> Statement()
    | <WHILE>  
   try 
   {
       <OPENPAR> Expression() <CLOSEPAR>
   }
   catch(ParseException e)
   {
       error_skipto(CLOSEPAR);
       ErrorManager.errorCounter++;
       if (ErrorManager.errorCounter == 10) throw e;   
   } Statement()
    | Expression3() ";"
    | <IDENTIFIER> (
        "=" Expression() ";"
            | "[" Expression() "]" ("=" Expression() ";" | ExpressionLFRFix())
            | ExpressionLFRFix2() ";" )
}

void Expression() : {}
{
     <INTEGERLITERAL> ExpressionLFRFix()
    | <TRUE> ExpressionLFRFix()
    | <FALSE> ExpressionLFRFix()
    | <IDENTIFIER> ExpressionLFRFix()
    | <THIS> ExpressionLFRFix()
    | <NEW> (<INT> "[" Expression() "]" | <IDENTIFIER> <OPENPAR> <CLOSEPAR> ) ExpressionLFRFix()
    | "!" Expression() ExpressionLFRFix()
    | <OPENPAR> Expression()  <CLOSEPAR> ExpressionLFRFix()
}

void Expression3() : {}
{
     <INTEGERLITERAL> ExpressionLFRFix()
    | <TRUE> ExpressionLFRFix()
    | <FALSE> ExpressionLFRFix()
    | <THIS> ExpressionLFRFix()
    | <NEW> (<INT> "[" Expression() "]" | <IDENTIFIER> <OPENPAR> <CLOSEPAR> ) ExpressionLFRFix()
    | "!" Expression() ExpressionLFRFix()
    | <OPENPAR> Expression()  <CLOSEPAR> ExpressionLFRFix()
}

void ExpressionLFRFix() : {}
{
    (LOOKAHEAD(2) (( "&&" | "<" | "+" | "-" | "*" | "/"  ) Expression() ExpressionLFRFix()
    | "[" Expression() "]" ExpressionLFRFix()
    | "." ( <IDENTIFIER> <OPENPAR> (Expression() ( "," Expression())*)? <CLOSEPAR> ExpressionLFRFix()  | <LENGTH> ExpressionLFRFix())  ))?
}

void ExpressionLFRFix2() : {}
{
    (( "&&" | "<" | "+" | "-" | "*" | "/"  ) Expression() ExpressionLFRFix()
    | "." ( <IDENTIFIER> <OPENPAR> (Expression() ( "," Expression())*)? <CLOSEPAR> ExpressionLFRFix()  | <LENGTH> ExpressionLFRFix()  ))?
}